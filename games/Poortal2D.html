<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Portal 2D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Disabilita zoom/scroll su mobile */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .instruction {
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            padding: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
        }
        /* Mobile Controls */
        .controls {
            pointer-events: auto;
            display: none; /* Nascosto su PC, visibile se touch */
            width: 100%;
            height: 100%;
            position: relative;
        }
        .joystick-area {
            position: absolute;
            bottom: 50px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        #stick-left { left: 30px; }
        #stick-right { right: 30px; }
        
        .stick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        #jump-btn {
            position: absolute;
            bottom: 220px;
            left: 30px;
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            pointer-events: auto;
        }

        @media (pointer: coarse) {
            .controls { display: block; }
            .instruction { display: none; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="instruction">WASD/Frecce per Muovere • Mouse per Mirare & Sparare • R per Reset</div>
    <div class="controls">
        <div id="jump-btn">JUMP</div>
        <div id="stick-left" class="joystick-area"><div class="stick-knob"></div></div>
        <div id="stick-right" class="joystick-area"><div class="stick-knob"></div></div>
    </div>
</div>
<canvas id="gameCanvas"></canvas>

<script>
// --- CONFIGURAZIONE & VARIABILI GLOBALI ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width, height;

// Physics constants
const GRAVITY = 0.5;
const FRICTION = 0.85;
const MOVE_SPEED = 1.2; // Accelerazione
const MAX_SPEED = 6;
const JUMP_FORCE = 12;

// Game State
const portals = { blue: null, orange: null, nextIsBlue: true };
const projectiles = [];
const particles = [];
const walls = [];

// Camera
let camX = 0, camY = 0;

// Input
const keys = {};
const mouse = { x: 0, y: 0, isDown: false };
const touchInput = {
    leftStick: { x: 0, y: 0, active: false, originX: 0, originY: 0, id: -1 },
    rightStick: { x: 0, y: 0, active: false, originX: 0, originY: 0, id: -1 },
    jump: false
};

// --- CLASSI ---

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 24;
        this.h = 24;
        this.velX = 0;
        this.velY = 0;
        this.grounded = false;
        this.color = '#fff';
        this.justTeleported = 0;
    }

    update() {
        // Input (Keyboard)
        if (keys['KeyA'] || keys['ArrowLeft']) this.velX -= MOVE_SPEED;
        if (keys['KeyD'] || keys['ArrowRight']) this.velX += MOVE_SPEED;
        if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && this.grounded) {
            this.velY = -JUMP_FORCE;
            this.grounded = false;
            createParticles(this.x + this.w/2, this.y + this.h, 5, '#fff');
        }

        // Input (Touch)
        if (touchInput.leftStick.active) {
            this.velX += touchInput.leftStick.x * MOVE_SPEED;
        }
        if (touchInput.jump && this.grounded) {
            this.velY = -JUMP_FORCE;
            this.grounded = false;
            touchInput.jump = false;
            createParticles(this.x + this.w/2, this.y + this.h, 5, '#fff');
        }

        // Physics
        this.velY += GRAVITY;
        this.velX *= FRICTION;
        
        // Cap speed
        if (this.velX > MAX_SPEED) this.velX = MAX_SPEED;
        if (this.velX < -MAX_SPEED) this.velX = -MAX_SPEED;

        // Move X
        this.x += this.velX;
        this.checkCollisions(true);

        // Move Y
        this.y += this.velY;
        this.grounded = false;
        this.checkCollisions(false);

        // Portal Interaction
        if (this.justTeleported > 0) this.justTeleported--;
        this.checkPortals();

        // Death check (fall out of world)
        if (this.y > 2000) resetGame();
    }

    checkCollisions(isX) {
        for (let wall of walls) {
            if (rectIntersect(this.x, this.y, this.w, this.h, wall.x, wall.y, wall.w, wall.h)) {
                if (isX) {
                    if (this.velX > 0) this.x = wall.x - this.w;
                    else if (this.velX < 0) this.x = wall.x + wall.w;
                    this.velX = 0;
                } else {
                    if (this.velY > 0) { // Falling
                        this.y = wall.y - this.h;
                        this.grounded = true;
                    } else if (this.velY < 0) { // Hitting head
                        this.y = wall.y + wall.h;
                    }
                    this.velY = 0;
                }
            }
        }
    }

    checkPortals() {
        if (this.justTeleported > 0) return;
        if (!portals.blue || !portals.orange) return;

        let hitPortal = null;
        let destPortal = null;

        if (rectIntersect(this.x, this.y, this.w, this.h, portals.blue.x - 10, portals.blue.y - 10, portals.blue.w + 20, portals.blue.h + 20)) {
            hitPortal = portals.blue;
            destPortal = portals.orange;
        } else if (rectIntersect(this.x, this.y, this.w, this.h, portals.orange.x - 10, portals.orange.y - 10, portals.orange.w + 20, portals.orange.h + 20)) {
            hitPortal = portals.orange;
            destPortal = portals.blue;
        }

        if (hitPortal && destPortal) {
            this.teleport(hitPortal, destPortal);
        }
    }

    teleport(entry, exit) {
        createParticles(this.x + this.w/2, this.y + this.h/2, 20, entry.color);
        
        // Posiziona il player all'uscita leggermente fuori
        const offset = 10;
        this.x = exit.x + (exit.w/2 - this.w/2) + (exit.nx * (this.w + offset));
        this.y = exit.y + (exit.h/2 - this.h/2) + (exit.ny * (this.h + offset));

        // Calcola la velocità relativa
        // Magnitudine della velocità corrente
        let speed = Math.sqrt(this.velX*this.velX + this.velY*this.velY);
        // Assicura una velocità minima per non rimanere bloccati
        if (speed < 5) speed = 5;

        // La nuova velocità è semplicemente la direzione della normale di uscita * speed
        // (Semplificazione per platformer 2D per renderlo più divertente/controllabile)
        this.velX = exit.nx * speed;
        this.velY = exit.ny * speed;

        // Se il portale è sul pavimento, spara verso l'alto con un po' più di forza
        if (exit.ny < 0) this.velY = -Math.max(speed, JUMP_FORCE * 1.2);

        this.justTeleported = 15; // Cooldown frame
        createParticles(this.x + this.w/2, this.y + this.h/2, 20, exit.color);
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        
        // Occhi
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'black';
        
        // Direzione sguardo
        let lookX = 0;
        if (mouse.x > 0 || touchInput.rightStick.active) {
             // Calcolato in draw loop ma approssimato qui
        }
        
        ctx.fillRect(this.x - camX + 4 + this.velX, this.y - camY + 4, 4, 4);
        ctx.fillRect(this.x - camX + 14 + this.velX, this.y - camY + 4, 4, 4);
    }
}

class Projectile {
    constructor(x, y, angle, isBlue) {
        this.x = x;
        this.y = y;
        this.speed = 15;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.isBlue = isBlue;
        this.color = isBlue ? '#00eaff' : '#ffaa00';
        this.active = true;
        this.size = 6;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        // Trail effect
        createParticles(this.x, this.y, 1, this.color, 0.5);

        // Collision with walls
        for (let wall of walls) {
            if (rectIntersect(this.x, this.y, this.size, this.size, wall.x, wall.y, wall.w, wall.h)) {
                this.active = false;
                this.createPortal(wall);
                createParticles(this.x, this.y, 10, this.color);
                break;
            }
        }
        
        if (this.x < -1000 || this.x > 4000 || this.y < -1000 || this.y > 4000) this.active = false;
    }

    createPortal(wall) {
        // Determina su quale lato del muro ha colpito
        // Semplice calcolo basato sulla penetrazione precedente
        let prevX = this.x - this.vx;
        let prevY = this.y - this.vy;
        
        let nx = 0, ny = 0;
        let px = this.x, py = this.y;
        let pw = 0, ph = 0;

        // Logica semplificata per determinare la normale
        // Se eravamo a sinistra/destra e ora siamo dentro -> Muro verticale
        // Se eravamo sopra/sotto e ora siamo dentro -> Muro orizzontale
        
        let overlapX = (prevX < wall.x) ? wall.x - prevX : prevX - (wall.x + wall.w);
        let overlapY = (prevY < wall.y) ? wall.y - prevY : prevY - (wall.y + wall.h);
        
        // Se era allineato orizzontalmente prima dell'impatto
        if (prevY + this.size > wall.y && prevY < wall.y + wall.h) {
             // Colpito lato
             if (this.vx > 0) { nx = -1; px = wall.x; } // Sinistra
             else { nx = 1; px = wall.x + wall.w; } // Destra
             pw = 4; ph = 50;
             py = this.y - 25; // Centra
        } else {
            // Colpito sopra/sotto
            if (this.vy > 0) { ny = -1; py = wall.y; } // Sopra
            else { ny = 1; py = wall.y + wall.h; } // Sotto
            pw = 50; ph = 4;
            px = this.x - 25; // Centra
        }

        // Clamp portale dentro il muro
        if (nx !== 0) {
            if (py < wall.y) py = wall.y;
            if (py + ph > wall.y + wall.h) py = wall.y + wall.h - ph;
        } else {
            if (px < wall.x) px = wall.x;
            if (px + pw > wall.x + wall.w) px = wall.x + wall.w - pw;
        }

        const portalData = { x: px, y: py, w: pw, h: ph, nx: nx, ny: ny, color: this.color };

        if (this.isBlue) portals.blue = portalData;
        else portals.orange = portalData;
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Particle {
    constructor(x, y, color, speedMult = 1) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4 * speedMult;
        this.vy = (Math.random() - 0.5) * 4 * speedMult;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * 4 + 1;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.04;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// --- UTILITIES ---

function createParticles(x, y, count, color, speedMult = 1) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, speedMult));
    }
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

// Raycast per la mira
function raycast(x, y, angle) {
    let rx = x;
    let ry = y;
    const step = 10;
    const maxDist = 800;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    
    for (let d = 0; d < maxDist; d += step) {
        rx += cos * step;
        ry += sin * step;
        
        for (let wall of walls) {
            if (rx > wall.x && rx < wall.x + wall.w && ry > wall.y && ry < wall.y + wall.h) {
                return { x: rx, y: ry, hit: true };
            }
        }
    }
    return { x: rx, y: ry, hit: false };
}

// --- MAPPA ---
function generateLevel() {
    walls.length = 0;
    // Pavimento
    walls.push({x: -500, y: 500, w: 3000, h: 100, c: '#444'});
    // Soffitto
    walls.push({x: -500, y: -500, w: 3000, h: 100, c: '#444'});
    // Muri laterali
    walls.push({x: -500, y: -500, w: 100, h: 1100, c: '#444'});
    walls.push({x: 2400, y: -500, w: 100, h: 1100, c: '#444'});

    // Piattaforme
    walls.push({x: 200, y: 350, w: 200, h: 40, c: '#666'});
    walls.push({x: 600, y: 200, w: 40, h: 250, c: '#666'}); // Muro verticale
    walls.push({x: 800, y: 400, w: 200, h: 40, c: '#666'});
    walls.push({x: 500, y: 50, w: 300, h: 40, c: '#666'});
    walls.push({x: 1100, y: 250, w: 40, h: 400, c: '#666'}); 
    walls.push({x: 1300, y: 100, w: 400, h: 40, c: '#666'});
    
    // Scatola chiusa (test portale)
    walls.push({x: 1800, y: 300, w: 200, h: 40, c: '#666'}); // floor
    walls.push({x: 1800, y: 100, w: 200, h: 40, c: '#666'}); // ceil
    walls.push({x: 1800, y: 100, w: 40, h: 240, c: '#666'}); // left
    // right open
}

let player = new Player(100, 400);
generateLevel();

function resetGame() {
    player = new Player(100, 400);
    portals.blue = null;
    portals.orange = null;
    portals.nextIsBlue = true;
    projectiles.length = 0;
}

// --- INPUT HANDLERS ---
window.addEventListener('resize', resize);
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
resize();

window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyR') resetGame();
});
window.addEventListener('keyup', e => keys[e.code] = false);

window.addEventListener('mousemove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});
window.addEventListener('mousedown', () => {
    mouse.isDown = true;
    shoot(mouse.x + camX, mouse.y + camY);
});
window.addEventListener('mouseup', () => mouse.isDown = false);

// Touch Logic
const stickLeftElem = document.getElementById('stick-left');
const stickRightElem = document.getElementById('stick-right');
const jumpBtn = document.getElementById('jump-btn');

function handleTouch(e, type) {
    e.preventDefault();
    const touches = e.changedTouches;
    
    for (let i = 0; i < touches.length; i++) {
        const t = touches[i];
        const tx = t.clientX;
        const ty = t.clientY;

        // Left Stick (Move)
        if (type === 'start' && tx < width / 2 && ty > height / 2 && !touchInput.leftStick.active && tx < width/2 - 80) {
            // Escludi area jump se possibile, o gestisci tramite target
        }
    }
}

// Configurazione Joysticks con Eventi DOM diretti per semplicità
stickLeftElem.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    touchInput.leftStick.id = t.identifier;
    touchInput.leftStick.active = true;
    const rect = stickLeftElem.getBoundingClientRect();
    touchInput.leftStick.originX = rect.left + rect.width/2;
    touchInput.leftStick.originY = rect.top + rect.height/2;
    updateStick(touchInput.leftStick, t.clientX, t.clientY, stickLeftElem);
}, {passive: false});

stickLeftElem.addEventListener('touchmove', e => {
    e.preventDefault();
    for (let i=0; i<e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchInput.leftStick.id) {
            const t = e.changedTouches[i];
            updateStick(touchInput.leftStick, t.clientX, t.clientY, stickLeftElem);
        }
    }
}, {passive: false});

stickLeftElem.addEventListener('touchend', e => {
    e.preventDefault();
    for (let i=0; i<e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchInput.leftStick.id) {
            touchInput.leftStick.active = false;
            touchInput.leftStick.x = 0;
            touchInput.leftStick.y = 0;
            resetStickVisual(stickLeftElem);
        }
    }
});

// Right Stick (Aim & Shoot on release)
stickRightElem.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    touchInput.rightStick.id = t.identifier;
    touchInput.rightStick.active = true;
    const rect = stickRightElem.getBoundingClientRect();
    touchInput.rightStick.originX = rect.left + rect.width/2;
    touchInput.rightStick.originY = rect.top + rect.height/2;
    updateStick(touchInput.rightStick, t.clientX, t.clientY, stickRightElem);
}, {passive: false});

stickRightElem.addEventListener('touchmove', e => {
    e.preventDefault();
    for (let i=0; i<e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchInput.rightStick.id) {
            const t = e.changedTouches[i];
            updateStick(touchInput.rightStick, t.clientX, t.clientY, stickRightElem);
        }
    }
}, {passive: false});

stickRightElem.addEventListener('touchend', e => {
    e.preventDefault();
    for (let i=0; i<e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchInput.rightStick.id) {
            // SHOOT!
            if (Math.abs(touchInput.rightStick.x) > 0.1 || Math.abs(touchInput.rightStick.y) > 0.1) {
                const angle = Math.atan2(touchInput.rightStick.y, touchInput.rightStick.x);
                fireProjectile(angle);
            }
            touchInput.rightStick.active = false;
            touchInput.rightStick.x = 0;
            touchInput.rightStick.y = 0;
            resetStickVisual(stickRightElem);
        }
    }
});

jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchInput.jump = true; });
jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); touchInput.jump = false; });

function updateStick(stick, cx, cy, elem) {
    const maxDist = 35;
    let dx = cx - stick.originX;
    let dy = cy - stick.originY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
    }
    
    // Normalize -1 to 1
    stick.x = dx / maxDist;
    stick.y = dy / maxDist;

    // Move Visual Knob
    const knob = elem.querySelector('.stick-knob');
    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

function resetStickVisual(elem) {
    const knob = elem.querySelector('.stick-knob');
    knob.style.transform = `translate(-50%, -50%)`;
}


function getAimInfo() {
    let targetX, targetY, angle;
    
    if (touchInput.rightStick.active && (Math.abs(touchInput.rightStick.x) > 0.1 || Math.abs(touchInput.rightStick.y) > 0.1)) {
        angle = Math.atan2(touchInput.rightStick.y, touchInput.rightStick.x);
    } else {
        // PC Mouse
        const dx = (mouse.x + camX) - (player.x + player.w/2);
        const dy = (mouse.y + camY) - (player.y + player.h/2);
        angle = Math.atan2(dy, dx);
    }
    return { angle };
}

function shoot(targetX, targetY) {
    const { angle } = getAimInfo();
    fireProjectile(angle);
}

function fireProjectile(angle) {
    const px = player.x + player.w/2;
    const py = player.y + player.h/2;
    projectiles.push(new Projectile(px, py, angle, portals.nextIsBlue));
    portals.nextIsBlue = !portals.nextIsBlue;
}

// --- RENDER & LOOP ---

function drawMap() {
    ctx.fillStyle = '#222';
    for (let w of walls) {
        ctx.fillStyle = w.c;
        // Bordo neon
        ctx.shadowBlur = 0;
        ctx.fillRect(w.x - camX, w.y - camY, w.w, w.h);
        
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.strokeRect(w.x - camX, w.y - camY, w.w, w.h);
    }
}

function drawPortals() {
    // Glow effect
    ctx.globalCompositeOperation = 'lighter';
    
    const drawP = (p) => {
        if (!p) return;
        ctx.shadowBlur = 20;
        ctx.shadowColor = p.color;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - camX, p.y - camY, p.w, p.h);
        
        // Inner white core
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 5;
        ctx.fillRect(p.x - camX + 2, p.y - camY + 2, p.w - 4, p.h - 4);
    };

    drawP(portals.blue);
    drawP(portals.orange);
    
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;
}

function drawTrajectory() {
    const { angle } = getAimInfo();
    
    // Se su mobile e stick destro non attivo, non disegnare
    if (touchInput.rightStick.id !== -1 && !touchInput.rightStick.active) return;
    // Su PC sempre attivo

    const startX = player.x + player.w/2;
    const startY = player.y + player.h/2;
    
    const hit = raycast(startX, startY, angle);
    
    const color = portals.nextIsBlue ? '0, 234, 255' : '255, 170, 0';
    
    // Disegna linea sfumata
    const grad = ctx.createLinearGradient(startX - camX, startY - camY, hit.x - camX, hit.y - camY);
    grad.addColorStop(0, `rgba(${color}, 0.8)`);
    grad.addColorStop(1, `rgba(${color}, 0)`);
    
    ctx.beginPath();
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2;
    ctx.moveTo(startX - camX, startY - camY);
    ctx.lineTo(hit.x - camX, hit.y - camY);
    ctx.stroke();
    
    // Disegna cerchietto finale
    if (hit.hit) {
        ctx.fillStyle = `rgba(${color}, 0.8)`;
        ctx.beginPath();
        ctx.arc(hit.x - camX, hit.y - camY, 4, 0, Math.PI*2);
        ctx.fill();
    }
}

function loop() {
    // Update
    player.update();
    
    for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update();
        if (!projectiles[i].active) projectiles.splice(i, 1);
    }
    
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    // Camera Follow Smooth
    let targetCamX = player.x - width / 2 + player.w / 2;
    let targetCamY = player.y - height / 2 + player.h / 2;
    camX += (targetCamX - camX) * 0.1;
    camY += (targetCamY - camY) * 0.1;

    // Draw
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, width, height);

    // Griglia sfondo
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    const gridSize = 50;
    const offX = camX % gridSize;
    const offY = camY % gridSize;
    for(let x = -offX; x < width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
    for(let y = -offY; y < height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
    ctx.stroke();

    drawMap();
    drawPortals();
    
    player.draw();
    
    projectiles.forEach(p => p.draw());
    particles.forEach(p => p.draw());
    
    drawTrajectory();

    requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>
